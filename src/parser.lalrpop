use crate::ast::{self, Binder, Def, Expr, Id, USort};

grammar;

pub Def: Def<USort> = {
    "def" <p:Id> ":" <ty:Term> ":=" <b:Term> ";" =>
        ast::def(p, Some(ty), Some(b)),
    "def" <p:Id> ":=" <b:Term> ";" =>
        ast::def(p, None, Some(b)),
    "axiom" <p:Id> ":" <ty:Term> ";" =>
        ast::def(p, Some(ty), None),
}

pub Program: Vec<Def<USort>> = {
    Def* => <>
}

pub Term: Expr<USort> = {
    "λ" <binders:Binders> "." <b:Term> =>
        ast::binders_to_lambda(binders, b),
    "Π" <binders:Binders> "." <b:Term> =>
        ast::binders_to_pi(binders, b),
    <e:Op> =>
        e,
}

Binders: Vec<Binder<USort>> = {
    <id:Id> ":" <ty:Term> =>
      vec![Binder { id, ty }],
    <proper_binders:Binder+> =>
      proper_binders,
}

Binder: Binder<USort> = {
    "(" <id:Id> ":" <ty:Term> ")" =>
      Binder { id, ty },
    <id:Id> =>
      Binder { id, ty: ast::blank() },
}

Op: Expr<USort> = {
    <e:Call> =>
        e,
    <left:Call> "->" <right:Op> =>
        ast::arrow(left, right),
}

Call: Expr<USort> = {
    <p:Prim> =>
        p,
    <f:Call> <a:Prim> =>
        ast::apply(f, a),
}

Prim: Expr<USort> = {
    "(" <t:Term> ")" =>
        t,
    <v:Id> =>
        ast::var_or_blank(v),
    "Type" =>
        ast::sort(USort::Type),
    "Kind" =>
        ast::sort(USort::Kind),
    "Triangle" =>
        ast::sort(USort::Triangle),
}

Id: Id = <s:r"\w+"> => Id::from(s);
