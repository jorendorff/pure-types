use crate::ast::{self, Def, Expr, Id, USort};

grammar;

pub Def: Def<USort> = {
    "def" <p:Id> ":" <ty:Term> ":=" <b:Term> ";" =>
        ast::def(p, Some(ty), Some(b)),
    "def" <p:Id> ":=" <b:Term> ";" =>
        ast::def(p, None, Some(b)),
    "axiom" <p:Id> ":" <ty:Term> ";" =>
        ast::def(p, Some(ty), None),
}

pub Program: Vec<Def<USort>> = {
    Def* => <>
}

pub Term: Expr<USort> = {
    "λ" "(" <p:Id> ":" <ty:Term> ")" "." <b:Term> =>
        ast::lambda(p, ty, b),
    "Π" "(" <p:Id> ":" <ty:Term> ")" "." <b:Term> =>
        ast::pi(p, ty, b),
    <e:Op> =>
        e,
}

Op: Expr<USort> = {
    <e:Call> =>
        e,
    <left:Call> "->" <right:Op> =>
        ast::arrow(left, right),
}

Call: Expr<USort> = {
    <p:Prim> =>
        p,
    <f:Call> <a:Prim> =>
        ast::apply(f, a),
}

Prim: Expr<USort> = {
    "(" <t:Term> ")" =>
        t,
    <v:Id> =>
        ast::var(v),
    "Type" =>
        ast::sort(USort::Type),
    "Kind" =>
        ast::sort(USort::Kind),
    "Triangle" =>
        ast::sort(USort::Triangle),
}

Id: Id = <s:r"\w+"> => Id::from(s);
